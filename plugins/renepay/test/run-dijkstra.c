#include "config.h"
#include <stdio.h>
#include <assert.h>
#include <common/wireaddr.h>
#include <common/bigsize.h>
#include <common/channel_id.h>
#include <common/setup.h>
#include <common/utils.h>

#include <plugins/renepay/dijkstra.h>

// #include <ccan/array_size/array_size.h>
// #include <ccan/read_write_all/read_write_all.h>
// #include <common/gossip_store.h>
// #include <common/node_id.h>
// #include <common/type_to_string.h>

// #include <bitcoin/short_channel_id.h>
// #include <ccan/htable/htable_type.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for fromwire_bigsize */
bigsize_t fromwire_bigsize(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bigsize called!\n"); abort(); }
/* Generated stub for fromwire_channel_id */
bool fromwire_channel_id(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
			 struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "fromwire_channel_id called!\n"); abort(); }
/* Generated stub for fromwire_wireaddr */
bool fromwire_wireaddr(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct wireaddr *addr UNNEEDED)
{ fprintf(stderr, "fromwire_wireaddr called!\n"); abort(); }
/* Generated stub for towire_bigsize */
void towire_bigsize(u8 **pptr UNNEEDED, const bigsize_t val UNNEEDED)
{ fprintf(stderr, "towire_bigsize called!\n"); abort(); }
/* Generated stub for towire_channel_id */
void towire_channel_id(u8 **pptr UNNEEDED, const struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "towire_channel_id called!\n"); abort(); }
/* Generated stub for towire_wireaddr */
void towire_wireaddr(u8 **pptr UNNEEDED, const struct wireaddr *addr UNNEEDED)
{ fprintf(stderr, "towire_wireaddr called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

static void insertion_in_increasing_distance(const tal_t *ctx)
{
	dijkstra_malloc(ctx,10);
	
	for(int i=0;i<dijkstra_maxsize();++i)
	{
		dijkstra_update(i,10+i);
		assert(dijkstra_size()==(i+1));
	}
	
	dijkstra_update(3,3);
	assert(dijkstra_top()==3);
	
	dijkstra_update(3,15);
	assert(dijkstra_top()==0);
	
	dijkstra_update(3,-1);
	assert(dijkstra_top()==3);
	
	dijkstra_pop();
	assert(dijkstra_size()==9);
	assert(dijkstra_top()==0);
	
	// Insert again
	dijkstra_update(3,3+10);

	u32 top=0;
	while(!dijkstra_empty())
	{
		assert(top==dijkstra_top());
		top++;
		dijkstra_pop();
	}
}
static void insertion_in_decreasing_distance(const tal_t *ctx)
{
	dijkstra_malloc(ctx,10);
	
	for(int i=0;i<dijkstra_maxsize();++i)
	{
		dijkstra_update(i,10-i);
		assert(dijkstra_size()==(i+1));
	}
	
	dijkstra_update(3,-3);
	assert(dijkstra_top()==3);
	
	dijkstra_update(3,15);
	assert(dijkstra_top()==9);
	
	dijkstra_update(3,-1);
	assert(dijkstra_top()==3);
	
	dijkstra_pop();
	assert(dijkstra_size()==9);
	assert(dijkstra_top()==9);
	
	// Insert again
	dijkstra_update(3,10-3);

	u32 top=9;
	while(!dijkstra_empty())
	{
		assert(top==dijkstra_top());
		top--;
		dijkstra_pop();
	}
}

int main(int argc, char *argv[])
{
	common_setup(argv[0]);
	
	insertion_in_increasing_distance(NULL);
	insertion_in_decreasing_distance(tmpctx);
	
	// test dijkstra_free
	dijkstra_free();
	// we can call it twice, no problem
	dijkstra_free();
	
	// does tal_free() cleansup correctly?
	const tal_t *this_ctx = tal(NULL,tal_t);
	insertion_in_increasing_distance(this_ctx);
	tal_free(this_ctx);
	insertion_in_decreasing_distance(tmpctx);
	
	common_shutdown();
}
