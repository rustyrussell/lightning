#include "config.h"
#include "../amount.c"
#include "../fp16.c"
#include "../gosstest.c"
#include "../gossmap.c"
#include "../node_id.c"
#include "../pseudorand.c"
#include "../../gossipd/gossip_store_wiregen.c"
#if EXPERIMENTAL_FEATURES
#include "../../wire/peer_exp_wiregen.c"
#else
#include "../../wire/peer_wiregen.c"
#endif
#include "../../wire/fromwire.c"
#include "../../wire/tlvstream.c"
#include "../../wire/towire.c"
#include <common/setup.h>

/* AUTOGENERATED MOCKS START */
/* Generated stub for fromwire_bigsize */
bigsize_t fromwire_bigsize(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bigsize called!\n"); abort(); }
/* Generated stub for fromwire_channel_id */
bool fromwire_channel_id(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
			 struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "fromwire_channel_id called!\n"); abort(); }
/* Generated stub for towire_bigsize */
void towire_bigsize(u8 **pptr UNNEEDED, const bigsize_t val UNNEEDED)
{ fprintf(stderr, "towire_bigsize called!\n"); abort(); }
/* Generated stub for towire_channel_id */
void towire_channel_id(u8 **pptr UNNEEDED, const struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "towire_channel_id called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

/* GRAPH a-b-bidir
 *
 * Alice<------>Bob
 */

/* GRAPH a-b-simplex
 *
 * Alice------->Bob
 */

/* GRAPH a-b-c-triangle
 *
 * Alice<----->Bob
 *  \           /
 *   \--Carol--/
 */

/* GRAPH a-b-labels
 *
 * Alice---------------->Bob
 *  ^       cap=100sat    |
 *  |       scid=1x2x3    |
 *  |      htlcmin=4msat  |
 *  |      htlcmax=5sat   |
 *  |       feebase=6     |
 *  |        feeppm=7    /
 *   \			/
 *    -----------------/
 *        scid=1x2x3
 *	  cap=100sat
 */

static void check_node(struct gossmap *gossmap, const char *name,
		       size_t n_chans)
{
	struct node_id expected_id;
	struct gossmap_node *node;
	u8 *ann;
	secp256k1_ecdsa_signature sig;
	u8 *features;
	u32 timestamp;
	struct node_id node_id;
	u8 rgb_color[3];
	u8 alias[32];
	u8 *addresses;
	struct tlv_node_ann_tlvs *tlvs;

	gosstest_node_id(name, &expected_id);

	node = gossmap_find_node(gossmap, &expected_id);
	assert(node);
	assert(node->num_chans == n_chans);

	ann = gossmap_node_get_announce(tmpctx, gossmap, node);
	assert(ann);

	assert(fromwire_node_announcement(tmpctx, ann, &sig, &features, &timestamp,
					  &node_id, rgb_color, alias, &addresses, &tlvs));
	assert(tal_bytelen(features) == 0);
	assert(timestamp <= time(NULL) && timestamp > time(NULL) - 10);
	assert(node_id_eq(&node_id, &expected_id));
	/* Assumes strlen(name) < 32! */
	assert(streq((const char *)alias, name));
	assert(tal_count(addresses) == 0);
}

static struct short_channel_id *default_scid(const tal_t *ctx,
					     const char *srcname,
					     const char *dstname,
					     const struct node_id *src,
					     const struct node_id *dst)
{
	/* Defaults to AxBx1 */
	struct short_channel_id *def = tal(ctx, struct short_channel_id);
	if (node_id_cmp(src, dst) < 0) {
		assert(mk_short_channel_id(def,
					   srcname[0], dstname[0], 1));
	} else {
		assert(mk_short_channel_id(def,
					   dstname[0], srcname[0], 1));
	}
	return def;
}

/* Make sure there's no channel_update for src's side of channel */
static void check_no_chan(struct gossmap *gossmap,
			  const char *srcname, const char *dstname,
			  const struct short_channel_id *scid)
{
	struct node_id src, dst;
	struct gossmap_node *first, *second;
	struct gossmap_chan *chan;
	int dir;

	gosstest_node_id(srcname, &src);
	gosstest_node_id(dstname, &dst);

	if (node_id_cmp(&src, &dst) < 0) {
		dir = 0;
		first = gossmap_find_node(gossmap, &src);
		second = gossmap_find_node(gossmap, &dst);
	} else {
		dir = 1;
		first = gossmap_find_node(gossmap, &dst);
		second = gossmap_find_node(gossmap, &src);
	}

	if (!scid)
		scid = default_scid(tmpctx, srcname, dstname, &src, &dst);
	chan = gossmap_find_chan(gossmap, scid);
	assert(chan);
	assert(gossmap_nth_node(gossmap, chan, 0) == first);
	assert(gossmap_nth_node(gossmap, chan, 1) == second);
	assert(!gossmap_chan_set(chan, dir));
}

static void check_chan(struct gossmap *gossmap,
		       const char *srcname, const char *dstname,
		       const struct short_channel_id *scid,
		       const struct amount_sat *capacity,
		       const u32 *fee_base_msat,
		       const u32 *fee_proportional_millionths,
		       const struct amount_msat *htlc_minimum_msat,
		       const struct amount_msat *htlc_maximum_msat)
{
	struct amount_sat actual_capacity;
	u32 actual_fee_base_msat;
	u32 actual_fee_proportional_millionths;
	struct amount_msat actual_htlc_minimum_msat;
	struct amount_msat actual_htlc_maximum_msat;
	struct node_id src, dst;
	struct gossmap_node *first, *second;
	struct gossmap_chan *chan;
	u32 timestamp;
	u8 message_flags, channel_flags;
	int dir;

	gosstest_node_id(srcname, &src);
	gosstest_node_id(dstname, &dst);

	if (node_id_cmp(&src, &dst) < 0) {
		dir = 0;
		first = gossmap_find_node(gossmap, &src);
		second = gossmap_find_node(gossmap, &dst);
	} else {
		dir = 1;
		first = gossmap_find_node(gossmap, &dst);
		second = gossmap_find_node(gossmap, &src);
	}

	if (!scid)
		scid = default_scid(tmpctx, srcname, dstname, &src, &dst);

	chan = gossmap_find_chan(gossmap, scid);
	assert(chan);
	assert(gossmap_nth_node(gossmap, chan, 0) == first);
	assert(gossmap_nth_node(gossmap, chan, 1) == second);

	/* Defaults to 100k sats */
	if (!capacity) {
		struct amount_sat def = AMOUNT_SAT(100000);
		capacity = tal_dup(tmpctx, struct amount_sat, &def);
	}
	if (!fee_base_msat) {
		u32 def = 0;
		fee_base_msat = tal_dup(tmpctx, u32, &def);
	}
	if (!fee_proportional_millionths) {
		u32 def = 0;
		fee_proportional_millionths = tal_dup(tmpctx, u32, &def);
	}
	if (!htlc_minimum_msat) {
		struct amount_msat def = AMOUNT_MSAT(0);
		htlc_minimum_msat = tal_dup(tmpctx, struct amount_msat, &def);
	}
	if (!htlc_maximum_msat) {
		struct amount_msat def;
		assert(amount_sat_to_msat(&def, *capacity));
		htlc_maximum_msat = tal_dup(tmpctx, struct amount_msat, &def);
	}
	assert(gossmap_chan_get_capacity(gossmap, chan, &actual_capacity));
	assert(amount_sat_eq(actual_capacity, *capacity));

	gossmap_chan_get_update_details(gossmap, chan, dir,
					&timestamp,
					&message_flags, &channel_flags,
					&actual_fee_base_msat,
					&actual_fee_proportional_millionths,
					&actual_htlc_minimum_msat,
					&actual_htlc_maximum_msat);
	assert(timestamp <= time(NULL) && timestamp > time(NULL) - 10);
	assert(actual_fee_base_msat == *fee_base_msat);
	assert(actual_fee_proportional_millionths == *fee_proportional_millionths);
	assert(amount_msat_eq(actual_htlc_minimum_msat, *htlc_minimum_msat));
	assert(amount_msat_eq(actual_htlc_maximum_msat, *htlc_maximum_msat));
}

int main(int argc, char *argv[])
{
	struct gossmap *gossmap;
	const char *fname;
	size_t num_rejected;
	struct short_channel_id scid;
	struct amount_sat capacity;
	u32 fee_base_msat, fee_proportional_millionths;
	struct amount_msat htlc_minimum_msat, htlc_maximum_msat;

	common_setup(argv[0]);

	fname = gosstest_from_comment(tmpctx, argv, "a-b-bidir");
	gossmap = gossmap_load(tmpctx, fname, &num_rejected);
	assert(gossmap);
	assert(num_rejected == 0);
	assert(gossmap_max_chan_idx(gossmap) == 1);

	check_node(gossmap, "Alice", 1);
	check_node(gossmap, "Bob", 1);

	check_chan(gossmap, "Alice", "Bob", NULL, NULL, NULL, NULL, NULL, NULL);
	check_chan(gossmap, "Bob", "Alice", NULL, NULL, NULL, NULL, NULL, NULL);

	fname = gosstest_from_comment(tmpctx, argv, "a-b-simplex");
	gossmap = gossmap_load(tmpctx, fname, &num_rejected);
	assert(gossmap);
	assert(num_rejected == 0);
	assert(gossmap_max_chan_idx(gossmap) == 1);

	check_node(gossmap, "Alice", 1);
	check_node(gossmap, "Bob", 1);

	check_chan(gossmap, "Alice", "Bob", NULL, NULL, NULL, NULL, NULL, NULL);
	check_no_chan(gossmap, "Bob", "Alice", NULL);

	fname = gosstest_from_comment(tmpctx, argv, "a-b-c-triangle");
	gossmap = gossmap_load(tmpctx, fname, &num_rejected);
	assert(gossmap);
	assert(num_rejected == 0);
	/* We actually double each time, so this will be 4 not 3! */
	assert(gossmap_max_chan_idx(gossmap) == 4);

	check_node(gossmap, "Alice", 2);
	check_node(gossmap, "Bob", 2);
	check_node(gossmap, "Carol", 2);

	check_chan(gossmap, "Alice", "Bob", NULL, NULL, NULL, NULL, NULL, NULL);
	check_chan(gossmap, "Bob", "Alice", NULL, NULL, NULL, NULL, NULL, NULL);
	check_chan(gossmap, "Alice", "Carol", NULL, NULL, NULL, NULL, NULL, NULL);
	check_chan(gossmap, "Carol", "Alice", NULL, NULL, NULL, NULL, NULL, NULL);
	check_chan(gossmap, "Bob", "Carol", NULL, NULL, NULL, NULL, NULL, NULL);
	check_chan(gossmap, "Carol", "Bob", NULL, NULL, NULL, NULL, NULL, NULL);

	fname = gosstest_from_comment(tmpctx, argv, "a-b-labels");
	gossmap = gossmap_load(tmpctx, fname, &num_rejected);
	assert(gossmap);
	assert(num_rejected == 0);
	assert(gossmap_max_chan_idx(gossmap) == 1);

	check_node(gossmap, "Alice", 1);
	check_node(gossmap, "Bob", 1);

	assert(mk_short_channel_id(&scid, 1, 2, 3));
	capacity = AMOUNT_SAT(100);
	fee_base_msat = 6;
	fee_proportional_millionths = 7;
	htlc_minimum_msat = AMOUNT_MSAT(4);
	htlc_maximum_msat = AMOUNT_MSAT(5000);

	check_chan(gossmap, "Alice", "Bob", &scid, &capacity,
		   &fee_base_msat, &fee_proportional_millionths,
		   &htlc_minimum_msat, &htlc_maximum_msat);
	/* Maximum is capped at capacity */
	check_chan(gossmap, "Bob", "Alice", &scid, &capacity,
		   NULL, NULL, NULL, NULL);

	common_shutdown();
	return 0;
}
